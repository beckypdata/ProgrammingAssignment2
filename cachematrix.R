## Solution for calculating the inverse of a square matrix
## Solution assumes matrix is a square matrix
## In order to optimize calculation, caching is leveraged for inverse previously calculated
## Two functions are needed to fully implement the caching solution
##   - makeCacheMatrix to set and retrieve initial matrix and calculated inverse as needed 
##   - cacheSolve calculates the inverse for matrix


## makeCacheMatrix takes as argument an initial matrix
## - makeCacheMatrix will create a special "vector"/list for specified matrix 
##    List generated contains as elements functions that set and retrieve initial
##       matrix as well as the inverse

makeCacheMatrix <- function(x = matrix()) {
    m <- NULL
    set <- function(y) {
      x <<- y
      m <<- NULL
    }
    get <- function() x
    setinverse <- function(xinv) m <<- xinv
    getinverse <- function() m
    list(set = set, get = get, 
         setinverse = setinverse, getinverse = getinverse)
}


## cacheSolve function is accessed for list structure previously generated by makeCacheMatrix
## cacheSolve will calculate the inverse for matrix referenced within list structure
## The first time accessed, the function will cache the result of the inverse calculation
## Subsequent call will return previously cached inverse and avoid need to calculate again

cacheSolve <- function(x, ...) {
    m <- x$getinverse()
    if(!is.null(m)) {
      message("getting cached data")
      return(m)
    }
    data <- x$get()
    m <- solve(data)
    x$setinverse(m)
    m
}

## Testing functions
## To begin create square matrix
z <- matrix(sample(1:100, 16), 4, 4)

## Now call the constructor for the list needed to contain associated functions
w <- makeCacheMatrix(z)

## Following demonstrates previous matrix referenced now with get function of list
message("Initial matrix")
print(w$get())

## Now calculate the inverse, reference through getinverse function of list
message("Calculated inverse")
zinv <- cacheSolve(w)
print(w$getinverse())

## Now repeat the calculation to demonstrate use of cached inverse
message("Demonstrate use of cached inverse matrix")
zinv <- cacheSolve(w)
print(w$getinverse())

## Following demonstrates accuracy of the calculated inverse with matrix
## multiplication of original matrix and inverse.  Result is identity matrix
message("Demonstrate accuracy of inverse matrix")
epsilon <- 1e-16
print(matrix(as.numeric(sprintf("%.13f", abs(abs(z%*%zinv)-epsilon))),4,4))

## Repeat with matrix 5x5
z <- matrix(sample(1:100, 25), 5, 5)

## Now call the constructor for the list needed to contain associated functions
w <- makeCacheMatrix(z)

## Following demonstrates previous matrix referenced now with get function of list
message("Initial matrix")
print(w$get())

## Now calculate the inverse, reference through getinverse function of list
message("Calculated inverse")
zinv <- cacheSolve(w)
print(w$getinverse())

## Now repeat the calculation to demonstrate use of cached inverse
message("Demonstrate use of cached inverse matrix")
zinv <- cacheSolve(w)
print(w$getinverse())

## Following demonstrates accuracy of the calculated inverse with matrix
## multiplication of original matrix and inverse.  Result is identity matrix
message("Demonstrate accuracy of inverse matrix")
print(matrix(as.numeric(sprintf("%.14f", abs(abs(z%*%zinv)-epsilon))),5,5))
